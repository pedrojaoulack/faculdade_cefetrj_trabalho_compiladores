Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> move_stmt
Rule 5     statement -> turn_stmt
Rule 6     statement -> pick_stmt
Rule 7     statement -> drop_stmt
Rule 8     statement -> assign_stmt
Rule 9     statement -> if_stmt
Rule 10    statement -> while_stmt
Rule 11    statement -> repeat_stmt
Rule 12    statement -> block
Rule 13    move_stmt -> MOVE direction SEMICOLON
Rule 14    turn_stmt -> TURN direction SEMICOLON
Rule 15    pick_stmt -> PICK STRING SEMICOLON
Rule 16    drop_stmt -> DROP SEMICOLON
Rule 17    direction -> UP
Rule 18    direction -> DOWN
Rule 19    direction -> LEFT
Rule 20    direction -> RIGHT
Rule 21    assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON
Rule 22    if_stmt -> IF LPAREN condition RPAREN block
Rule 23    if_stmt -> IF LPAREN condition RPAREN block ELSE block
Rule 24    while_stmt -> WHILE LPAREN condition RPAREN block
Rule 25    repeat_stmt -> REPEAT expression TIMES block
Rule 26    block -> LBRACE statement_list RBRACE
Rule 27    condition -> expression EQUALS expression
Rule 28    condition -> expression NOTEQUALS expression
Rule 29    condition -> expression LESS expression
Rule 30    condition -> expression GREATER expression
Rule 31    condition -> expression LESSEQUAL expression
Rule 32    condition -> expression GREATEREQUAL expression
Rule 33    expression -> expression PLUS expression
Rule 34    expression -> expression MINUS expression
Rule 35    expression -> expression MULTIPLY expression
Rule 36    expression -> expression DIVIDE expression
Rule 37    expression -> LPAREN expression RPAREN
Rule 38    expression -> NUMBER
Rule 39    expression -> IDENTIFIER

Terminals, with rules where they appear

ASSIGN               : 21
COMMA                : 
DIVIDE               : 36
DOWN                 : 18
DROP                 : 16
ELSE                 : 23
EQUALS               : 27
GREATER              : 30
GREATEREQUAL         : 32
IDENTIFIER           : 21 39
IF                   : 22 23
LBRACE               : 26
LEFT                 : 19
LESS                 : 29
LESSEQUAL            : 31
LPAREN               : 22 23 24 37
MINUS                : 34
MOVE                 : 13
MULTIPLY             : 35
NOTEQUALS            : 28
NUMBER               : 38
PICK                 : 15
PLUS                 : 33
RBRACE               : 26
REPEAT               : 25
RIGHT                : 20
RPAREN               : 22 23 24 37
SEMICOLON            : 13 14 15 16 21
STRING               : 15
TIMES                : 25
TURN                 : 14
UP                   : 17
WHILE                : 24
error                : 

Nonterminals, with rules where they appear

assign_stmt          : 8
block                : 12 22 23 23 24 25
condition            : 22 23 24
direction            : 13 14
drop_stmt            : 7
expression           : 21 25 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37
if_stmt              : 9
move_stmt            : 4
pick_stmt            : 6
program              : 0
repeat_stmt          : 11
statement            : 2 3
statement_list       : 1 2 26
turn_stmt            : 5
while_stmt           : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . move_stmt
    (5) statement -> . turn_stmt
    (6) statement -> . pick_stmt
    (7) statement -> . drop_stmt
    (8) statement -> . assign_stmt
    (9) statement -> . if_stmt
    (10) statement -> . while_stmt
    (11) statement -> . repeat_stmt
    (12) statement -> . block
    (13) move_stmt -> . MOVE direction SEMICOLON
    (14) turn_stmt -> . TURN direction SEMICOLON
    (15) pick_stmt -> . PICK STRING SEMICOLON
    (16) drop_stmt -> . DROP SEMICOLON
    (21) assign_stmt -> . IDENTIFIER ASSIGN expression SEMICOLON
    (22) if_stmt -> . IF LPAREN condition RPAREN block
    (23) if_stmt -> . IF LPAREN condition RPAREN block ELSE block
    (24) while_stmt -> . WHILE LPAREN condition RPAREN block
    (25) repeat_stmt -> . REPEAT expression TIMES block
    (26) block -> . LBRACE statement_list RBRACE

    MOVE            shift and go to state 13
    TURN            shift and go to state 14
    PICK            shift and go to state 15
    DROP            shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    REPEAT          shift and go to state 20
    LBRACE          shift and go to state 21

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    move_stmt                      shift and go to state 4
    turn_stmt                      shift and go to state 5
    pick_stmt                      shift and go to state 6
    drop_stmt                      shift and go to state 7
    assign_stmt                    shift and go to state 8
    if_stmt                        shift and go to state 9
    while_stmt                     shift and go to state 10
    repeat_stmt                    shift and go to state 11
    block                          shift and go to state 12

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . move_stmt
    (5) statement -> . turn_stmt
    (6) statement -> . pick_stmt
    (7) statement -> . drop_stmt
    (8) statement -> . assign_stmt
    (9) statement -> . if_stmt
    (10) statement -> . while_stmt
    (11) statement -> . repeat_stmt
    (12) statement -> . block
    (13) move_stmt -> . MOVE direction SEMICOLON
    (14) turn_stmt -> . TURN direction SEMICOLON
    (15) pick_stmt -> . PICK STRING SEMICOLON
    (16) drop_stmt -> . DROP SEMICOLON
    (21) assign_stmt -> . IDENTIFIER ASSIGN expression SEMICOLON
    (22) if_stmt -> . IF LPAREN condition RPAREN block
    (23) if_stmt -> . IF LPAREN condition RPAREN block ELSE block
    (24) while_stmt -> . WHILE LPAREN condition RPAREN block
    (25) repeat_stmt -> . REPEAT expression TIMES block
    (26) block -> . LBRACE statement_list RBRACE

    $end            reduce using rule 1 (program -> statement_list .)
    MOVE            shift and go to state 13
    TURN            shift and go to state 14
    PICK            shift and go to state 15
    DROP            shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    REPEAT          shift and go to state 20
    LBRACE          shift and go to state 21

    statement                      shift and go to state 22
    move_stmt                      shift and go to state 4
    turn_stmt                      shift and go to state 5
    pick_stmt                      shift and go to state 6
    drop_stmt                      shift and go to state 7
    assign_stmt                    shift and go to state 8
    if_stmt                        shift and go to state 9
    while_stmt                     shift and go to state 10
    repeat_stmt                    shift and go to state 11
    block                          shift and go to state 12

state 3

    (3) statement_list -> statement .

    MOVE            reduce using rule 3 (statement_list -> statement .)
    TURN            reduce using rule 3 (statement_list -> statement .)
    PICK            reduce using rule 3 (statement_list -> statement .)
    DROP            reduce using rule 3 (statement_list -> statement .)
    IDENTIFIER      reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    WHILE           reduce using rule 3 (statement_list -> statement .)
    REPEAT          reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)


state 4

    (4) statement -> move_stmt .

    MOVE            reduce using rule 4 (statement -> move_stmt .)
    TURN            reduce using rule 4 (statement -> move_stmt .)
    PICK            reduce using rule 4 (statement -> move_stmt .)
    DROP            reduce using rule 4 (statement -> move_stmt .)
    IDENTIFIER      reduce using rule 4 (statement -> move_stmt .)
    IF              reduce using rule 4 (statement -> move_stmt .)
    WHILE           reduce using rule 4 (statement -> move_stmt .)
    REPEAT          reduce using rule 4 (statement -> move_stmt .)
    LBRACE          reduce using rule 4 (statement -> move_stmt .)
    $end            reduce using rule 4 (statement -> move_stmt .)
    RBRACE          reduce using rule 4 (statement -> move_stmt .)


state 5

    (5) statement -> turn_stmt .

    MOVE            reduce using rule 5 (statement -> turn_stmt .)
    TURN            reduce using rule 5 (statement -> turn_stmt .)
    PICK            reduce using rule 5 (statement -> turn_stmt .)
    DROP            reduce using rule 5 (statement -> turn_stmt .)
    IDENTIFIER      reduce using rule 5 (statement -> turn_stmt .)
    IF              reduce using rule 5 (statement -> turn_stmt .)
    WHILE           reduce using rule 5 (statement -> turn_stmt .)
    REPEAT          reduce using rule 5 (statement -> turn_stmt .)
    LBRACE          reduce using rule 5 (statement -> turn_stmt .)
    $end            reduce using rule 5 (statement -> turn_stmt .)
    RBRACE          reduce using rule 5 (statement -> turn_stmt .)


state 6

    (6) statement -> pick_stmt .

    MOVE            reduce using rule 6 (statement -> pick_stmt .)
    TURN            reduce using rule 6 (statement -> pick_stmt .)
    PICK            reduce using rule 6 (statement -> pick_stmt .)
    DROP            reduce using rule 6 (statement -> pick_stmt .)
    IDENTIFIER      reduce using rule 6 (statement -> pick_stmt .)
    IF              reduce using rule 6 (statement -> pick_stmt .)
    WHILE           reduce using rule 6 (statement -> pick_stmt .)
    REPEAT          reduce using rule 6 (statement -> pick_stmt .)
    LBRACE          reduce using rule 6 (statement -> pick_stmt .)
    $end            reduce using rule 6 (statement -> pick_stmt .)
    RBRACE          reduce using rule 6 (statement -> pick_stmt .)


state 7

    (7) statement -> drop_stmt .

    MOVE            reduce using rule 7 (statement -> drop_stmt .)
    TURN            reduce using rule 7 (statement -> drop_stmt .)
    PICK            reduce using rule 7 (statement -> drop_stmt .)
    DROP            reduce using rule 7 (statement -> drop_stmt .)
    IDENTIFIER      reduce using rule 7 (statement -> drop_stmt .)
    IF              reduce using rule 7 (statement -> drop_stmt .)
    WHILE           reduce using rule 7 (statement -> drop_stmt .)
    REPEAT          reduce using rule 7 (statement -> drop_stmt .)
    LBRACE          reduce using rule 7 (statement -> drop_stmt .)
    $end            reduce using rule 7 (statement -> drop_stmt .)
    RBRACE          reduce using rule 7 (statement -> drop_stmt .)


state 8

    (8) statement -> assign_stmt .

    MOVE            reduce using rule 8 (statement -> assign_stmt .)
    TURN            reduce using rule 8 (statement -> assign_stmt .)
    PICK            reduce using rule 8 (statement -> assign_stmt .)
    DROP            reduce using rule 8 (statement -> assign_stmt .)
    IDENTIFIER      reduce using rule 8 (statement -> assign_stmt .)
    IF              reduce using rule 8 (statement -> assign_stmt .)
    WHILE           reduce using rule 8 (statement -> assign_stmt .)
    REPEAT          reduce using rule 8 (statement -> assign_stmt .)
    LBRACE          reduce using rule 8 (statement -> assign_stmt .)
    $end            reduce using rule 8 (statement -> assign_stmt .)
    RBRACE          reduce using rule 8 (statement -> assign_stmt .)


state 9

    (9) statement -> if_stmt .

    MOVE            reduce using rule 9 (statement -> if_stmt .)
    TURN            reduce using rule 9 (statement -> if_stmt .)
    PICK            reduce using rule 9 (statement -> if_stmt .)
    DROP            reduce using rule 9 (statement -> if_stmt .)
    IDENTIFIER      reduce using rule 9 (statement -> if_stmt .)
    IF              reduce using rule 9 (statement -> if_stmt .)
    WHILE           reduce using rule 9 (statement -> if_stmt .)
    REPEAT          reduce using rule 9 (statement -> if_stmt .)
    LBRACE          reduce using rule 9 (statement -> if_stmt .)
    $end            reduce using rule 9 (statement -> if_stmt .)
    RBRACE          reduce using rule 9 (statement -> if_stmt .)


state 10

    (10) statement -> while_stmt .

    MOVE            reduce using rule 10 (statement -> while_stmt .)
    TURN            reduce using rule 10 (statement -> while_stmt .)
    PICK            reduce using rule 10 (statement -> while_stmt .)
    DROP            reduce using rule 10 (statement -> while_stmt .)
    IDENTIFIER      reduce using rule 10 (statement -> while_stmt .)
    IF              reduce using rule 10 (statement -> while_stmt .)
    WHILE           reduce using rule 10 (statement -> while_stmt .)
    REPEAT          reduce using rule 10 (statement -> while_stmt .)
    LBRACE          reduce using rule 10 (statement -> while_stmt .)
    $end            reduce using rule 10 (statement -> while_stmt .)
    RBRACE          reduce using rule 10 (statement -> while_stmt .)


state 11

    (11) statement -> repeat_stmt .

    MOVE            reduce using rule 11 (statement -> repeat_stmt .)
    TURN            reduce using rule 11 (statement -> repeat_stmt .)
    PICK            reduce using rule 11 (statement -> repeat_stmt .)
    DROP            reduce using rule 11 (statement -> repeat_stmt .)
    IDENTIFIER      reduce using rule 11 (statement -> repeat_stmt .)
    IF              reduce using rule 11 (statement -> repeat_stmt .)
    WHILE           reduce using rule 11 (statement -> repeat_stmt .)
    REPEAT          reduce using rule 11 (statement -> repeat_stmt .)
    LBRACE          reduce using rule 11 (statement -> repeat_stmt .)
    $end            reduce using rule 11 (statement -> repeat_stmt .)
    RBRACE          reduce using rule 11 (statement -> repeat_stmt .)


state 12

    (12) statement -> block .

    MOVE            reduce using rule 12 (statement -> block .)
    TURN            reduce using rule 12 (statement -> block .)
    PICK            reduce using rule 12 (statement -> block .)
    DROP            reduce using rule 12 (statement -> block .)
    IDENTIFIER      reduce using rule 12 (statement -> block .)
    IF              reduce using rule 12 (statement -> block .)
    WHILE           reduce using rule 12 (statement -> block .)
    REPEAT          reduce using rule 12 (statement -> block .)
    LBRACE          reduce using rule 12 (statement -> block .)
    $end            reduce using rule 12 (statement -> block .)
    RBRACE          reduce using rule 12 (statement -> block .)


state 13

    (13) move_stmt -> MOVE . direction SEMICOLON
    (17) direction -> . UP
    (18) direction -> . DOWN
    (19) direction -> . LEFT
    (20) direction -> . RIGHT

    UP              shift and go to state 24
    DOWN            shift and go to state 25
    LEFT            shift and go to state 26
    RIGHT           shift and go to state 27

    direction                      shift and go to state 23

state 14

    (14) turn_stmt -> TURN . direction SEMICOLON
    (17) direction -> . UP
    (18) direction -> . DOWN
    (19) direction -> . LEFT
    (20) direction -> . RIGHT

    UP              shift and go to state 24
    DOWN            shift and go to state 25
    LEFT            shift and go to state 26
    RIGHT           shift and go to state 27

    direction                      shift and go to state 28

state 15

    (15) pick_stmt -> PICK . STRING SEMICOLON

    STRING          shift and go to state 29


state 16

    (16) drop_stmt -> DROP . SEMICOLON

    SEMICOLON       shift and go to state 30


state 17

    (21) assign_stmt -> IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 31


state 18

    (22) if_stmt -> IF . LPAREN condition RPAREN block
    (23) if_stmt -> IF . LPAREN condition RPAREN block ELSE block

    LPAREN          shift and go to state 32


state 19

    (24) while_stmt -> WHILE . LPAREN condition RPAREN block

    LPAREN          shift and go to state 33


state 20

    (25) repeat_stmt -> REPEAT . expression TIMES block
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 34

state 21

    (26) block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . move_stmt
    (5) statement -> . turn_stmt
    (6) statement -> . pick_stmt
    (7) statement -> . drop_stmt
    (8) statement -> . assign_stmt
    (9) statement -> . if_stmt
    (10) statement -> . while_stmt
    (11) statement -> . repeat_stmt
    (12) statement -> . block
    (13) move_stmt -> . MOVE direction SEMICOLON
    (14) turn_stmt -> . TURN direction SEMICOLON
    (15) pick_stmt -> . PICK STRING SEMICOLON
    (16) drop_stmt -> . DROP SEMICOLON
    (21) assign_stmt -> . IDENTIFIER ASSIGN expression SEMICOLON
    (22) if_stmt -> . IF LPAREN condition RPAREN block
    (23) if_stmt -> . IF LPAREN condition RPAREN block ELSE block
    (24) while_stmt -> . WHILE LPAREN condition RPAREN block
    (25) repeat_stmt -> . REPEAT expression TIMES block
    (26) block -> . LBRACE statement_list RBRACE

    MOVE            shift and go to state 13
    TURN            shift and go to state 14
    PICK            shift and go to state 15
    DROP            shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    REPEAT          shift and go to state 20
    LBRACE          shift and go to state 21

    statement_list                 shift and go to state 38
    statement                      shift and go to state 3
    move_stmt                      shift and go to state 4
    turn_stmt                      shift and go to state 5
    pick_stmt                      shift and go to state 6
    drop_stmt                      shift and go to state 7
    assign_stmt                    shift and go to state 8
    if_stmt                        shift and go to state 9
    while_stmt                     shift and go to state 10
    repeat_stmt                    shift and go to state 11
    block                          shift and go to state 12

state 22

    (2) statement_list -> statement_list statement .

    MOVE            reduce using rule 2 (statement_list -> statement_list statement .)
    TURN            reduce using rule 2 (statement_list -> statement_list statement .)
    PICK            reduce using rule 2 (statement_list -> statement_list statement .)
    DROP            reduce using rule 2 (statement_list -> statement_list statement .)
    IDENTIFIER      reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 2 (statement_list -> statement_list statement .)
    REPEAT          reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement_list statement .)


state 23

    (13) move_stmt -> MOVE direction . SEMICOLON

    SEMICOLON       shift and go to state 39


state 24

    (17) direction -> UP .

    SEMICOLON       reduce using rule 17 (direction -> UP .)


state 25

    (18) direction -> DOWN .

    SEMICOLON       reduce using rule 18 (direction -> DOWN .)


state 26

    (19) direction -> LEFT .

    SEMICOLON       reduce using rule 19 (direction -> LEFT .)


state 27

    (20) direction -> RIGHT .

    SEMICOLON       reduce using rule 20 (direction -> RIGHT .)


state 28

    (14) turn_stmt -> TURN direction . SEMICOLON

    SEMICOLON       shift and go to state 40


state 29

    (15) pick_stmt -> PICK STRING . SEMICOLON

    SEMICOLON       shift and go to state 41


state 30

    (16) drop_stmt -> DROP SEMICOLON .

    MOVE            reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    TURN            reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    PICK            reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    DROP            reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    IDENTIFIER      reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    IF              reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    WHILE           reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    REPEAT          reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    LBRACE          reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    $end            reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)
    RBRACE          reduce using rule 16 (drop_stmt -> DROP SEMICOLON .)


state 31

    (21) assign_stmt -> IDENTIFIER ASSIGN . expression SEMICOLON
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 42

state 32

    (22) if_stmt -> IF LPAREN . condition RPAREN block
    (23) if_stmt -> IF LPAREN . condition RPAREN block ELSE block
    (27) condition -> . expression EQUALS expression
    (28) condition -> . expression NOTEQUALS expression
    (29) condition -> . expression LESS expression
    (30) condition -> . expression GREATER expression
    (31) condition -> . expression LESSEQUAL expression
    (32) condition -> . expression GREATEREQUAL expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    condition                      shift and go to state 43
    expression                     shift and go to state 44

state 33

    (24) while_stmt -> WHILE LPAREN . condition RPAREN block
    (27) condition -> . expression EQUALS expression
    (28) condition -> . expression NOTEQUALS expression
    (29) condition -> . expression LESS expression
    (30) condition -> . expression GREATER expression
    (31) condition -> . expression LESSEQUAL expression
    (32) condition -> . expression GREATEREQUAL expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    condition                      shift and go to state 45
    expression                     shift and go to state 44

state 34

    (25) repeat_stmt -> REPEAT expression . TIMES block
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    TIMES           shift and go to state 46
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 35

    (37) expression -> LPAREN . expression RPAREN
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 51

state 36

    (38) expression -> NUMBER .

    TIMES           reduce using rule 38 (expression -> NUMBER .)
    PLUS            reduce using rule 38 (expression -> NUMBER .)
    MINUS           reduce using rule 38 (expression -> NUMBER .)
    MULTIPLY        reduce using rule 38 (expression -> NUMBER .)
    DIVIDE          reduce using rule 38 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 38 (expression -> NUMBER .)
    EQUALS          reduce using rule 38 (expression -> NUMBER .)
    NOTEQUALS       reduce using rule 38 (expression -> NUMBER .)
    LESS            reduce using rule 38 (expression -> NUMBER .)
    GREATER         reduce using rule 38 (expression -> NUMBER .)
    LESSEQUAL       reduce using rule 38 (expression -> NUMBER .)
    GREATEREQUAL    reduce using rule 38 (expression -> NUMBER .)
    RPAREN          reduce using rule 38 (expression -> NUMBER .)


state 37

    (39) expression -> IDENTIFIER .

    TIMES           reduce using rule 39 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 39 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 39 (expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 39 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 39 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 39 (expression -> IDENTIFIER .)
    EQUALS          reduce using rule 39 (expression -> IDENTIFIER .)
    NOTEQUALS       reduce using rule 39 (expression -> IDENTIFIER .)
    LESS            reduce using rule 39 (expression -> IDENTIFIER .)
    GREATER         reduce using rule 39 (expression -> IDENTIFIER .)
    LESSEQUAL       reduce using rule 39 (expression -> IDENTIFIER .)
    GREATEREQUAL    reduce using rule 39 (expression -> IDENTIFIER .)
    RPAREN          reduce using rule 39 (expression -> IDENTIFIER .)


state 38

    (26) block -> LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (4) statement -> . move_stmt
    (5) statement -> . turn_stmt
    (6) statement -> . pick_stmt
    (7) statement -> . drop_stmt
    (8) statement -> . assign_stmt
    (9) statement -> . if_stmt
    (10) statement -> . while_stmt
    (11) statement -> . repeat_stmt
    (12) statement -> . block
    (13) move_stmt -> . MOVE direction SEMICOLON
    (14) turn_stmt -> . TURN direction SEMICOLON
    (15) pick_stmt -> . PICK STRING SEMICOLON
    (16) drop_stmt -> . DROP SEMICOLON
    (21) assign_stmt -> . IDENTIFIER ASSIGN expression SEMICOLON
    (22) if_stmt -> . IF LPAREN condition RPAREN block
    (23) if_stmt -> . IF LPAREN condition RPAREN block ELSE block
    (24) while_stmt -> . WHILE LPAREN condition RPAREN block
    (25) repeat_stmt -> . REPEAT expression TIMES block
    (26) block -> . LBRACE statement_list RBRACE

    RBRACE          shift and go to state 52
    MOVE            shift and go to state 13
    TURN            shift and go to state 14
    PICK            shift and go to state 15
    DROP            shift and go to state 16
    IDENTIFIER      shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    REPEAT          shift and go to state 20
    LBRACE          shift and go to state 21

    statement                      shift and go to state 22
    move_stmt                      shift and go to state 4
    turn_stmt                      shift and go to state 5
    pick_stmt                      shift and go to state 6
    drop_stmt                      shift and go to state 7
    assign_stmt                    shift and go to state 8
    if_stmt                        shift and go to state 9
    while_stmt                     shift and go to state 10
    repeat_stmt                    shift and go to state 11
    block                          shift and go to state 12

state 39

    (13) move_stmt -> MOVE direction SEMICOLON .

    MOVE            reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    TURN            reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    PICK            reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    DROP            reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    IDENTIFIER      reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    IF              reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    WHILE           reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    REPEAT          reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    LBRACE          reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    $end            reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)
    RBRACE          reduce using rule 13 (move_stmt -> MOVE direction SEMICOLON .)


state 40

    (14) turn_stmt -> TURN direction SEMICOLON .

    MOVE            reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    TURN            reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    PICK            reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    DROP            reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    IDENTIFIER      reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    IF              reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    WHILE           reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    REPEAT          reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    LBRACE          reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    $end            reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)
    RBRACE          reduce using rule 14 (turn_stmt -> TURN direction SEMICOLON .)


state 41

    (15) pick_stmt -> PICK STRING SEMICOLON .

    MOVE            reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    TURN            reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    PICK            reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    DROP            reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    IDENTIFIER      reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    IF              reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    WHILE           reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    REPEAT          reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    LBRACE          reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    $end            reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)
    RBRACE          reduce using rule 15 (pick_stmt -> PICK STRING SEMICOLON .)


state 42

    (21) assign_stmt -> IDENTIFIER ASSIGN expression . SEMICOLON
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    SEMICOLON       shift and go to state 53
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 43

    (22) if_stmt -> IF LPAREN condition . RPAREN block
    (23) if_stmt -> IF LPAREN condition . RPAREN block ELSE block

    RPAREN          shift and go to state 54


state 44

    (27) condition -> expression . EQUALS expression
    (28) condition -> expression . NOTEQUALS expression
    (29) condition -> expression . LESS expression
    (30) condition -> expression . GREATER expression
    (31) condition -> expression . LESSEQUAL expression
    (32) condition -> expression . GREATEREQUAL expression
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    EQUALS          shift and go to state 55
    NOTEQUALS       shift and go to state 56
    LESS            shift and go to state 57
    GREATER         shift and go to state 58
    LESSEQUAL       shift and go to state 59
    GREATEREQUAL    shift and go to state 60
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 45

    (24) while_stmt -> WHILE LPAREN condition . RPAREN block

    RPAREN          shift and go to state 61


state 46

    (25) repeat_stmt -> REPEAT expression TIMES . block
    (26) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 62

state 47

    (33) expression -> expression PLUS . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 63

state 48

    (34) expression -> expression MINUS . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 64

state 49

    (35) expression -> expression MULTIPLY . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 65

state 50

    (36) expression -> expression DIVIDE . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 66

state 51

    (37) expression -> LPAREN expression . RPAREN
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          shift and go to state 67
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 52

    (26) block -> LBRACE statement_list RBRACE .

    MOVE            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    TURN            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    PICK            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    DROP            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    REPEAT          reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 26 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 26 (block -> LBRACE statement_list RBRACE .)


state 53

    (21) assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .

    MOVE            reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    TURN            reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    PICK            reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    DROP            reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    REPEAT          reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    LBRACE          reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 21 (assign_stmt -> IDENTIFIER ASSIGN expression SEMICOLON .)


state 54

    (22) if_stmt -> IF LPAREN condition RPAREN . block
    (23) if_stmt -> IF LPAREN condition RPAREN . block ELSE block
    (26) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 68

state 55

    (27) condition -> expression EQUALS . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 69

state 56

    (28) condition -> expression NOTEQUALS . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 70

state 57

    (29) condition -> expression LESS . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 71

state 58

    (30) condition -> expression GREATER . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 72

state 59

    (31) condition -> expression LESSEQUAL . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 73

state 60

    (32) condition -> expression GREATEREQUAL . expression
    (33) expression -> . expression PLUS expression
    (34) expression -> . expression MINUS expression
    (35) expression -> . expression MULTIPLY expression
    (36) expression -> . expression DIVIDE expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . NUMBER
    (39) expression -> . IDENTIFIER

    LPAREN          shift and go to state 35
    NUMBER          shift and go to state 36
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 74

state 61

    (24) while_stmt -> WHILE LPAREN condition RPAREN . block
    (26) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 75

state 62

    (25) repeat_stmt -> REPEAT expression TIMES block .

    MOVE            reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    TURN            reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    PICK            reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    DROP            reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    IDENTIFIER      reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    IF              reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    WHILE           reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    REPEAT          reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    LBRACE          reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    $end            reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)
    RBRACE          reduce using rule 25 (repeat_stmt -> REPEAT expression TIMES block .)


state 63

    (33) expression -> expression PLUS expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    TIMES           reduce using rule 33 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 33 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 33 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 33 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 33 (expression -> expression PLUS expression .)
    NOTEQUALS       reduce using rule 33 (expression -> expression PLUS expression .)
    LESS            reduce using rule 33 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 33 (expression -> expression PLUS expression .)
    LESSEQUAL       reduce using rule 33 (expression -> expression PLUS expression .)
    GREATEREQUAL    reduce using rule 33 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 33 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50

  ! MULTIPLY        [ reduce using rule 33 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 33 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]


state 64

    (34) expression -> expression MINUS expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    TIMES           reduce using rule 34 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 34 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 34 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 34 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 34 (expression -> expression MINUS expression .)
    NOTEQUALS       reduce using rule 34 (expression -> expression MINUS expression .)
    LESS            reduce using rule 34 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 34 (expression -> expression MINUS expression .)
    LESSEQUAL       reduce using rule 34 (expression -> expression MINUS expression .)
    GREATEREQUAL    reduce using rule 34 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 34 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50

  ! MULTIPLY        [ reduce using rule 34 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 34 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]


state 65

    (35) expression -> expression MULTIPLY expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    TIMES           reduce using rule 35 (expression -> expression MULTIPLY expression .)
    PLUS            reduce using rule 35 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 35 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 35 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 35 (expression -> expression MULTIPLY expression .)
    SEMICOLON       reduce using rule 35 (expression -> expression MULTIPLY expression .)
    EQUALS          reduce using rule 35 (expression -> expression MULTIPLY expression .)
    NOTEQUALS       reduce using rule 35 (expression -> expression MULTIPLY expression .)
    LESS            reduce using rule 35 (expression -> expression MULTIPLY expression .)
    GREATER         reduce using rule 35 (expression -> expression MULTIPLY expression .)
    LESSEQUAL       reduce using rule 35 (expression -> expression MULTIPLY expression .)
    GREATEREQUAL    reduce using rule 35 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 35 (expression -> expression MULTIPLY expression .)

  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]
  ! MULTIPLY        [ shift and go to state 49 ]
  ! DIVIDE          [ shift and go to state 50 ]


state 66

    (36) expression -> expression DIVIDE expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    TIMES           reduce using rule 36 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 36 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 36 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 36 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 36 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 36 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 36 (expression -> expression DIVIDE expression .)
    NOTEQUALS       reduce using rule 36 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 36 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 36 (expression -> expression DIVIDE expression .)
    LESSEQUAL       reduce using rule 36 (expression -> expression DIVIDE expression .)
    GREATEREQUAL    reduce using rule 36 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 36 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 47 ]
  ! MINUS           [ shift and go to state 48 ]
  ! MULTIPLY        [ shift and go to state 49 ]
  ! DIVIDE          [ shift and go to state 50 ]


state 67

    (37) expression -> LPAREN expression RPAREN .

    TIMES           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    NOTEQUALS       reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    LESS            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    LESSEQUAL       reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    GREATEREQUAL    reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 37 (expression -> LPAREN expression RPAREN .)


state 68

    (22) if_stmt -> IF LPAREN condition RPAREN block .
    (23) if_stmt -> IF LPAREN condition RPAREN block . ELSE block

    MOVE            reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    TURN            reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    PICK            reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    DROP            reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    IDENTIFIER      reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    IF              reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    WHILE           reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    REPEAT          reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    LBRACE          reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    $end            reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    RBRACE          reduce using rule 22 (if_stmt -> IF LPAREN condition RPAREN block .)
    ELSE            shift and go to state 76


state 69

    (27) condition -> expression EQUALS expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 27 (condition -> expression EQUALS expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 70

    (28) condition -> expression NOTEQUALS expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 28 (condition -> expression NOTEQUALS expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 71

    (29) condition -> expression LESS expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 29 (condition -> expression LESS expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 72

    (30) condition -> expression GREATER expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 30 (condition -> expression GREATER expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 73

    (31) condition -> expression LESSEQUAL expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 31 (condition -> expression LESSEQUAL expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 74

    (32) condition -> expression GREATEREQUAL expression .
    (33) expression -> expression . PLUS expression
    (34) expression -> expression . MINUS expression
    (35) expression -> expression . MULTIPLY expression
    (36) expression -> expression . DIVIDE expression

    RPAREN          reduce using rule 32 (condition -> expression GREATEREQUAL expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    MULTIPLY        shift and go to state 49
    DIVIDE          shift and go to state 50


state 75

    (24) while_stmt -> WHILE LPAREN condition RPAREN block .

    MOVE            reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    TURN            reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    PICK            reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    DROP            reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    IDENTIFIER      reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    IF              reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    WHILE           reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    REPEAT          reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    LBRACE          reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    $end            reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)
    RBRACE          reduce using rule 24 (while_stmt -> WHILE LPAREN condition RPAREN block .)


state 76

    (23) if_stmt -> IF LPAREN condition RPAREN block ELSE . block
    (26) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 77

state 77

    (23) if_stmt -> IF LPAREN condition RPAREN block ELSE block .

    MOVE            reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    TURN            reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    PICK            reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    DROP            reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    IDENTIFIER      reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    IF              reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    WHILE           reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    REPEAT          reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    LBRACE          reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    $end            reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)
    RBRACE          reduce using rule 23 (if_stmt -> IF LPAREN condition RPAREN block ELSE block .)

